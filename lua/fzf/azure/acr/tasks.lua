local core = require("fzf.core")
local helpers = require("fzf.helpers")
local fzf_utils = require("fzf.utils")
local utils = require("utils")
local json = require("utils.json")
local shared = require("fzf.azure.shared")
local task_runs = require("fzf.azure.acr.task_runs")

local manual = {
  agentConfiguration = "Configuration for the task agent, including CPU allocation.",
  agentPoolName = "The name of the agent pool that executes the task.",
  creationDate = "The date and time when the task was created.",
  credentials = "Credentials used by the task for accessing external resources.",
  id = "The fully qualified identifier for the task.",
  identity = "Managed identity associated with the task.",
  isSystemTask = "Indicates if the task is a system task.",
  location = "The location of the task.",
  logTemplate = "Template for logs generated by the task.",
  name = "The name of the task.",
  platform = {
    architecture = "The architecture target for the task (e.g., amd64).",
    os = "The operating system target for the task (e.g., linux).",
    variant = "A variant of the OS/architecture, if applicable.",
  },
  provisioningState = "The provisioning state of the task.",
  resourceGroup = "The resource group to which the task belongs.",
  status = "The enabled or disabled status of the task.",
  step = {
    baseImageDependencies = "Dependencies on base images for the task.",
    contextAccessToken = "Access token for the context if the context requires authentication.",
    contextPath = "The path to the task's context in the source repository.",
    encodedTaskContent = "Base64-encoded content of the task.",
    encodedValuesContent = "Base64-encoded values for the task.",
    type = "The type of step that the task performs.",
    values = "Values to override the defaults within the task definition.",
  },
  systemData = {
    createdAt = "The date and time when the task was created.",
    createdBy = "The email or identifier of the creator of the task.",
    createdByType = "The type of identity that created the task.",
    lastModifiedAt = "The date and time when the task was last modified.",
    lastModifiedBy = "The email or identifier of the last modifier of the task.",
    lastModifiedByType = "The type of identity that last modified the task.",
  },
  tags = "Tags associated with the task.",
  timeout = "Maximum time in seconds that the task is allowed to run.",
  trigger = {
    baseImageTrigger = {
      baseImageTriggerType = "The type of trigger based on the base image (e.g., Runtime).",
      name = "The name of the base image trigger.",
      status = "The status of the base image trigger.",
      updateTriggerEndpoint = "Endpoint to receive notifications when the base image is updated.",
      updateTriggerPayloadType = "The payload type for update notifications.",
    },
    sourceTriggers = "Triggers based on changes to the source code repository.",
    timerTriggers = {
      {
        name = "Name of the timer trigger.",
        schedule = "Cron schedule for the timer trigger.",
        status = "The status of the timer trigger.",
      },
    },
  },
  type = "The resource type of the task.",
}

-- Fzf all configured tasks under the acr.
--
---@param acr azure_container_registry
---@param opts? { parent_state?: string }
return function(acr, opts)
  opts = vim.tbl_extend("force", {}, opts or {})

  ---@alias acr_task { agentConfiguration: string, agentPoolName: string, creationDate: string, credentials: string, id: string, identity: string, isSystemTask: string, location: string, logTemplate: string, name: string, platform: { architecture: string, os: string, variant: string }, provisioningState: string, resourceGroup: string, status: string, step: { baseImageDependencies: string, contextAccessToken: string, contextPath: string, encodedTaskContent: string, encodedValuesContent: string, type: string, values: string }, systemData: { createdAt: string, createdBy: string, createdByType: string, lastModifiedAt: string, lastModifiedBy: string, lastModifiedByType: string }, tags: string, timeout: string, trigger: { baseImageTrigger: { baseImageTriggerType: string, name: string, status: string, updateTriggerEndpoint: string, updateTriggerPayloadType: string }, sourceTriggers: string, timerTriggers: { name: string, schedule: string, status: string } }, type: string }
  ---@type acr_task[]
  local tasks

  local function get_entries()
    if not shared.is_azurecli_available() then error("Azure cli not found") end

    local command = string.format("az acr task list -r %s", acr.name)
    local result = vim.fn.system(command)
    if vim.v.shell_error ~= 0 then
      _error(
        "Fail to retrieve any configured tasks under the azure container registry",
        result
      )
      return {}
    end

    result = vim.trim(result)
    tasks = json.parse(result) ---@diagnostic disable-line: cast-local-type
    ---@cast tasks acr_task[]

    return utils.map(
      tasks,
      function(i, task) return fzf_utils.join_by_delim(task.name) end
    )
  end

  local layout, popups, set_preview_content =
    helpers.create_nvim_preview_layout()

  core.fzf(get_entries(), {
    prompt = "ACR-Tasks",
    layout = layout,
    main_popup = popups.main,
    binds = {
      ["+before-start"] = function(state)
        helpers.set_keymaps_for_preview_remote_nav(
          popups.main,
          popups.nvim_preview
        )
        helpers.set_keymaps_for_popups_nav({
          { popup = popups.main, key = "<C-s>", is_terminal = true },
          { popup = popups.nvim_preview, key = "<C-f>", is_terminal = false },
        })
      end,
      ["focus"] = function(state)
        local task = tasks[state.focused_entry_index]

        popups.nvim_preview.border:set_text("top", " " .. task.name .. " ")

        set_preview_content(vim.split(vim.inspect(task), "\n"))
        vim.bo[popups.nvim_preview.bufnr].filetype = "lua"
      end,
      ["ctrl-y"] = function(state)
        local task = tasks[state.focused_entry_index]
        vim.fn.setreg("+", task.id)
        vim.notify(string.format([[Copied %s to clipboard]], task.id))
      end,
      ["ctrl-t"] = function(state)
        local task = tasks[state.focused_entry_index]

        local command = string.format(
          [[az acr task run -n "%s" -r "%s"]],
          task.name,
          acr.name
        )

        vim.fn.setreg("+", command)
        vim.notify(string.format([[Copied %s to clipboard]], command))
      end,
      ["ctrl-r"] = function(state)
        local task = tasks[state.focused_entry_index]

        task_runs(task, acr, { parent_state = state.id })
      end,
    },
    extra_args = vim.tbl_extend("force", helpers.fzf_default_args, {
      ["--with-nth"] = "1..",
    }),
  }, opts.parent_state)
end
